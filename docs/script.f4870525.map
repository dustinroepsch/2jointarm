{"version":3,"sources":["script.ts"],"names":[],"mappings":";AAAA,IAAI,EAA4B,SAAS,eAAe,cAEpD,EAAgC,EAAO,WAAW,MAEtD,EAAA,WAEI,SAAA,IACS,KAAA,SAAW,KAAK,MAQ7B,OALW,EAAA,UAAA,KAAP,WACQ,IAAA,EAAgB,KAAK,MAAQ,KAAK,SAE/B,OADF,KAAA,SAAW,KAAK,MACd,EAAQ,KAEvB,EAXA,GAYA,EAAA,WAEA,OADI,SAAmB,EAAkB,GAAlB,KAAA,EAAA,EAAkB,KAAA,EAAA,GADzC,GAIA,SAAS,EAAY,EAAQ,GACrB,IAAA,EAAO,EAAO,wBACX,OAAA,IAAI,EACP,EAAI,QAAU,EAAK,KACnB,EAAI,QAAU,EAAK,KAI3B,SAAS,EAAS,EAAU,GACjB,OAAA,KAAK,KAAK,KAAA,IAAC,EAAE,EAAI,EAAE,EAAM,GAAI,KAAA,IAAC,EAAE,EAAI,EAAE,EAAM,IAGvD,SAAS,EAAS,GAET,IADD,IAAA,EAAc,EAAE,QACX,EAAI,EAAG,EAAI,EAAE,OAAQ,IAC1B,EAAE,KAAO,KAAK,SAAW,IAAM,IAE5B,OAAA,EAIX,IAAA,EAAA,WAKI,SAAA,EAAmB,EAA0B,EAAmB,GAA7C,KAAA,UAAA,EAA0B,KAAA,UAAA,EAFtC,KAAA,OAAmB,GAGjB,IAAA,IAAI,EAAY,EAAG,EAAI,EAAW,IAC9B,KAAA,OAAO,KAAK,GAEhB,KAAA,UAAY,EAAO,OAAS,EAAY,IAqDrD,OAjDI,EAAA,UAAA,OAAA,WAKsB,IAJd,IAAA,EAAe,KAAK,UACpB,EAAe,KAAK,UAGN,EAAA,EAAA,EAAA,KAAK,OAAL,EAAA,EAAA,OAAA,IAAa,CAAtB,IAAA,EAAK,EAAA,GACV,EAAI,YACJ,EAAI,QAAQ,EAAM,EAAM,GAAI,GAAI,EAAG,EAAa,EAAV,KAAK,IAC3C,EAAI,SAEJ,EAAI,YACJ,EAAI,OAAO,EAAM,GACjB,GAAQ,KAAK,UAAY,KAAK,IAAI,GAClC,GAAQ,KAAK,UAAY,KAAK,IAAI,GAClC,EAAI,OAAO,EAAM,GACjB,EAAI,SAER,EAAI,YACJ,EAAI,QAAQ,EAAM,EAAM,GAAI,GAAI,EAAG,EAAa,EAAV,KAAK,IAC3C,EAAI,UAKA,EAAA,UAAA,cAAR,WAIsB,IAHd,IAAA,EAAO,KAAK,UACZ,EAAO,KAAK,UAEE,EAAA,EAAA,EAAA,KAAK,OAAL,EAAA,EAAA,OAAA,IAAa,CAAtB,IAAA,EAAK,EAAA,GACV,GAAQ,KAAK,UAAY,KAAK,IAAI,GAClC,GAAQ,KAAK,UAAY,KAAK,IAAI,GAE/B,OAAA,IAAI,EAAM,EAAM,IAGpB,EAAA,UAAA,YAAP,SAAmB,GACX,IAAA,EAAmB,EAAS,KAAK,gBAAiB,GAClD,KAAA,EAAmB,KAKlB,IAFD,IAAA,EAA2B,KAAK,OAAO,QAElC,EAAY,EAAG,EAAI,IAAK,IAEzB,GADC,KAAA,OAAS,EAAS,GACnB,EAAS,KAAK,gBAAiB,GAAO,EACtC,QAIhB,EA9DA,GAiEI,EAAW,IAAI,EAAI,EAAO,MAAQ,GAAI,EAAO,OAAS,GAAI,GAC1D,EAAa,IAAI,EAAM,EAAG,GAO9B,SAAS,IACL,EAAI,UAAU,EAAG,EAAG,EAAO,MAAO,EAAO,QACzC,EAAI,SARR,EAAO,iBAAiB,YAAa,SAAC,GAClC,EAAM,EAAY,EAAQ,KAY9B,IAAI,EAAuB,IAAI,EAC/B,SAAS,IACA,IAAA,IAAI,EAAI,EAAG,EAAI,IAAM,IACtB,EAAI,YAAY,GAGpB,IACA,sBAAsB,GAG1B,sBAAsB","file":"script.f4870525.map","sourceRoot":"..","sourcesContent":["let canvas: HTMLCanvasElement = document.getElementById(\"mainCanvas\") as HTMLCanvasElement;\n\nlet ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\n\nclass Stopwatch {\n    private lastTime: number;\n    constructor() {\n        this.lastTime = Date.now();\n    }\n\n    public tick() {\n        let delta: number = Date.now() - this.lastTime;\n        this.lastTime = Date.now();\n        return delta / 1000; //seconds\n    }\n}\nclass Point {\n    constructor(public x: number, public y: number) { }\n}\n\nfunction getMousePos(canvas, evt): Point {\n    var rect = canvas.getBoundingClientRect();\n    return new Point(\n        evt.clientX - rect.left,\n        evt.clientY - rect.top\n    );\n}\n\nfunction distance(a: Point, b: Point): number {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n}\n\nfunction modulate(a: number[]): number[] {\n    let x: number[] = a.slice();\n    for (let i = 0; i < x.length; i++) {\n        x[i] += (Math.random() - .5) / 150;\n    }\n    return x;\n}\n\n\nclass Arm {\n    private armLength: number;\n\n    public angles: number[] = [];\n\n    constructor(public positionX: number, public positionY: number, numAngles: number) {\n        for (let i: number = 0; i < numAngles; i++) {\n            this.angles.push(0);\n        }\n        this.armLength = canvas.width / (numAngles + .5);\n    }\n\n\n    render(): void {\n        let curX: number = this.positionX;\n        let curY: number = this.positionY;\n\n\n        for (let angle of this.angles) {\n            ctx.beginPath();\n            ctx.ellipse(curX, curY, 15, 15, 0, 0, Math.PI * 2);\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(curX, curY);\n            curX += this.armLength * Math.cos(angle);\n            curY += this.armLength * Math.sin(angle);\n            ctx.lineTo(curX, curY);\n            ctx.stroke();\n        }\n        ctx.beginPath();\n        ctx.ellipse(curX, curY, 15, 15, 0, 0, Math.PI * 2);\n        ctx.stroke();\n\n\n    }\n\n    private getFinalPoint(): Point {\n        let curX = this.positionX;\n        let curY = this.positionY;\n\n        for (let angle of this.angles) {\n            curX += this.armLength * Math.cos(angle);\n            curY += this.armLength * Math.sin(angle);\n        }\n        return new Point(curX, curY);\n    }\n\n    public moveTowards(pos: Point) {\n        let startingDistance = distance(this.getFinalPoint(), pos);\n        if (startingDistance < 0.01) {\n            return;\n        }\n        let startingAngles: number[] = this.angles.slice();\n\n        for (let i: number = 0; i < 200; i++) {\n            this.angles = modulate(startingAngles);\n            if (distance(this.getFinalPoint(), pos) < startingDistance) {\n                return;\n            }\n        }\n    }\n}\n\n\nlet arm: Arm = new Arm(canvas.width / 10, canvas.height / 10, 4);\nlet pos: Point = new Point(0, 0);\ncanvas.addEventListener(\"mousemove\", (evt) => {\n    pos = getMousePos(canvas, evt);\n})\n\n\n\nfunction render() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    arm.render();\n}\n\n\n\nlet stopwatch: Stopwatch = new Stopwatch();\nfunction mainLoop(): void {\n    for (let i = 0; i < 1000; i++) {\n        arm.moveTowards(pos);\n    }\n\n    render();\n    requestAnimationFrame(mainLoop);\n}\n\nrequestAnimationFrame(mainLoop);\n"]}